/*+----------------------------------------------------------------+
  |	Title:		util_str.hpp [共通環境]
  |	Comment:	文字列関連（※基本的に[NULL]は空文字[""]扱い）
  |	Author:		K.Takayanagi
  +----------------------------------------------------------------+*/
/*+----------------------------------------------------------------+
  |	Header Define	ヘッダ定義
  +----------------------------------------------------------------+*/
#ifndef __UTIL_STR_HPP__
#define __UTIL_STR_HPP__

/*+----------------------------------------------------------------+
  |	Include		インクルードヘッダ
  +----------------------------------------------------------------+*/
#include "env.hpp"

/*+----------------------------------------------------------------+
  |	Define		デファイン定義
  +----------------------------------------------------------------+*/
// 書式合わせのため（※一応）
#define util_str_n_cpy( _pB, _pS, _size )   strncpy( (_pB), (_pS), (_size) )

// １６進数表記の接頭子の削除（※[const char*]、[char*]の混在が予想されるのでマクロにしておく）
#define util_str_trim_hex_prefix( _pStr )           \
    if( (_pStr)[0] == '0' && (_pStr)[1] == 'x' ){   \
        (_pStr) += 2;                               \
    }

/*+----------------------------------------------------------------+
  |	Function	関数
  +----------------------------------------------------------------+*/
/*+----------------------------------------------------------------+
  |	Struct		構造体型宣言
  +----------------------------------------------------------------+*/
/*+----------------------------------------------------------------+
  |	Global		グローバルデータ型定義
  +----------------------------------------------------------------+*/
/*+----------------------------------------------------------------+
  |	Prototype	プロトタイプ宣言
  +----------------------------------------------------------------+*/
//--------------------------------------------
// 文字列長の取得（※基本的には[strlen]）
//--------------------------------------------
extern int util_str_len( const char* pStr );

//--------------------------------------------
// 文字列の比較（※基本的には[strcmp]）
//--------------------------------------------
extern int util_str_cmp( const char* pStr0, const char* pStr1, int bufSize=0 );

//-------------------------------------------------------------------------------
// 文字列のコピー（※基本的には[strcpy/strncpy]）
// 正常終了の場合[true]を返す（※文字列が渡されたバッファに収まった場合）
// [false]の場合、入力文字が長すぎて途中までしかコピーができなかったことを意味する
//-------------------------------------------------------------------------------
extern bool util_str_cpy( char* pBuf, const char* pSrc, int bufSize );

//-------------------------------------------------------------------------------
// TSVを想定した区切り文字による部分文字列抽出関連（※自由入力形式の文字列を含むデータ向け）
// 要素の末尾を[separator]で指定した文字列データを並べた内容を[pSrc]で受け取って処理する
//-------------------------------------------------------------------------------
// 例えば下記のようなデータがあった場合、
//  "abc\t1234\tfalse\tHello, World."
// 下記のように扱うことができる（※最終要素の末端に分割指定がない場合は、pSrcの終端を割り当てる）
//  element[0] = "abc"
//  element[1] = "1234"
//  element[2] = "false"
//  element[3] = "Hello, World."
// バッファに収まらない文字列に対しては終端を省略した抽出も可能
// 上記例において、抽出バッファサイズが８文字(終端枠含め)なら最後の要素は下記として抽出される
//  element[3] = "Hell..."  // 切り捨てられる領域が"..."で置き換えられる
//-------------------------------------------------------------------------------
// TSV処理した際の要素数と、その終端の確認（※想定よりも要素が少ない場合は[false]が返る）
extern bool util_str_tsv_check_element_end( const char* pSrc, int* pEnd, int supposedNum, char separator='\t' );

// 有効な pEnd に対して、指定番目の要素をバッファに読み込む
extern bool util_str_tsv_read_at( char* pBuf, const char* pSrc, int bufSize, int* pEnd, int elementAt, bool isOmittedIfOverflow=false );

// TSVバッファに文字列を追加する（※返値は追加後の文字列長）
extern int util_str_tsv_add_str( char* pBuf, const char* pStr, int ofs, int bufSize, char separator='\t' );

//-------------------------------------------------------------------------------
// CSVを想定した区切り文字による文字列分割関連（※数字のみを扱うデータ向け）
// 呼び出し元の文字列を破壊する点に注意（※[util_str_csv_split]が区切り文字を'\0'に置換する）
//-------------------------------------------------------------------------------
// 例えば下記のようなデータがあった場合、
//  "1,23,ABC\n2,34,BCD\n3,45,CDE"
// [util_str_csv_split]を'\n'で呼ぶことで、
//  split[0] = "1,23,ABC"
//  split[1] = "2,34,BCD"
//  split[2] = "3,45,CDE"
// のような分割文字列を[util_str_csv_get_next]にて得ることができる
// さらに各分割文字列に対して、[util_str_csv_split]を','でよぶことで、
//  split[0][0] = "1"
//  split[0][1] = "23"
//  split[0][2] = "ABC"
// のような文字列を得ることができる
//-----------------------------------------------------------------------
// 指定の区切り文字を検索して '\0' に置き換える（※返値は要素数）
extern int util_str_csv_split( char* pBuf, char separator=',' );

// 文字列終端の次の位置を返す（※[util_str_csv_split]後の文字列に対して逐次部分文字列を取得する）
extern char* util_str_csv_get_next( char* pBuf );

// 文字列を出力して区切り文字を挿入した位置を返す（※文字列のCSV出力用）
extern int util_str_csv_print_str( char* pBuf, const char* pStr, int ofs, int bufSize, char separator=',' );

// [uint64]の値を10進数で出力して区切り文字を挿入した位置を返す（※数字のCSV出力用）
extern int util_str_csv_print_decimal_uint64( char* pBuf, uint64 val, int ofs, int bufSize, char separator=',' );

// 区切り文字の変換
extern int util_str_csv_change_separator( char* pBuf, char separatorFrom, char separatorTo );

//-------------------------------------------------------------------------------
// 符号なし数値の読み書き関連
//-------------------------------------------------------------------------------
// 10進数表記の文字列からビットサイズで指定する値域で値を読み込む
extern uint64 util_str_read_decimal_uint64_with_bit_range( const char* pSrc, int bitNum );

// ブロックチェーンワード(16進数のuint256文字列)から文字単位で読み込む（※ビッグエンディアン）
extern uint64 util_str_read_blockchain_word_with_char_range( const char* pSrc, int strLen, int readNum, int readOfs );

// ブロックチェーンのワード(16進数のuint256文字列)を出力する（※ビッグエンディアン）
extern bool util_str_print_blockchain_word_with_separator( char*pBuf, int bufSize, BYTE* pWords, int numWords, char separator=',' );

#endif /* __UTIL_STR_HPP__ */
